import logging
import ignition.model.lifecycle as lifecycle_model
import ignition.model.failure as failure_model
from ignition.service.framework import Service
from ignition.service.resourcedriver import ResourceDriverHandlerCapability, InvalidRequestError, RequestNotFoundError
from kubedriver.location import KubeDeploymentLocation
from kubedriver.persistence import RecordNotFoundError
from kubedriver.kegd.model import StrategyExecutionStates, InvalidDeploymentStrategyError
from kubedriver.kegd.strategy_files import KegDeploymentStrategyFiles
from .topology import KubeAssociatedTopology

logger = logging.getLogger(__name__)

class KubeResourceDriverHandler(Service, ResourceDriverHandlerCapability):

    def __init__(self, resource_driver_properties, kegd_strategy_manager, kegd_file_reader, render_context_service, name_manager):
        self.resource_driver_properties = resource_driver_properties
        self.kegd_strategy_manager = kegd_strategy_manager
        self.kegd_file_reader = kegd_file_reader
        self.render_context_service = render_context_service
        self.name_manager = name_manager

    def execute_lifecycle(self, lifecycle_name, driver_files, system_properties, resource_properties, request_properties, associated_topology, deployment_location):
        """
        Execute a lifecycle transition/operation for a Resource. Executes the kegd strategy for the Resource.

        :param str lifecycle_name: name of the lifecycle transition/operation to execute
        :param ignition.utils.file.DirectoryTree driver_files: object for navigating the directory of the kubernetes driver files from the Resource package.
        :param ignition.utils.propvaluemap.PropValueMap system_properties: properties generated by LM for this Resource: resourceId, resourceName, requestId, metricKey, resourceManagerId, deploymentLocation, resourceType
        :param ignition.utils.propvaluemap.PropValueMap resource_properties: property values of the Resource
        :param ignition.utils.propvaluemap.PropValueMap request_properties: property values of this request
        :param ignition.model.associated_topology.AssociatedTopology associated_topology: 3rd party resources associated to the Resource, from any previous transition/operation requests
        :param dict deployment_location: the deployment location the Resource is assigned to
        :return: an ignition.model.lifecycle.LifecycleExecuteResponse

        :raises:
            ignition.service.resourcedriver.InvalidRequestError: if the deployment strategy is not valid
        """
        kube_location = None
        try:
            kube_location = self.__translate_location(deployment_location)
            render_context = self.render_context_service.build(system_properties, resource_properties, request_properties, kube_location.to_dict())
            keg_name = self.__generate_keg_name(system_properties)
            kegd_files = KegDeploymentStrategyFiles(driver_files.root_path)
            try:
                kegd_strategy = self.kegd_file_reader.read(kegd_files.get_strategy_file(), render_context)
                request_id = self.kegd_strategy_manager.apply_kegd_strategy(kube_location, keg_name, kegd_strategy, lifecycle_name, kegd_files, render_context)
            except InvalidDeploymentStrategyError as e:
                raise InvalidRequestError(f'{e}') from e
            return lifecycle_model.LifecycleExecuteResponse(request_id)
        finally:
            keep_files = self.resource_driver_properties.keep_files
            if not keep_files and driver_files is not None:
                try:
                    logger.debug(f'Attempting to remove driver files at {driver_files.root_path}')
                    driver_files.remove_all()
                except Exception as e:
                    logger.exception(f'Encountered an error whilst trying to clear out driver files directory {driver_files.root_path}: {e}')
            if kube_location != None:
                try:
                    logger.debug(f'Attempting to clean up deployment location related files')
                    kube_location.clean()
                except Exception as e:
                    logger.exception(f'Encountered an error whilst trying to clean up deployment location related files: {e}')

    def get_lifecycle_execution(self, request_id, deployment_location):
        """
        Retrieve the status of a lifecycle transition/operation request by finding the matching Kegd report.

        :param str request_id: identifier of the request to check
        :param dict deployment_location: the deployment location the Resource is assigned to
        :return: an ignition.model.lifecycle.LifecycleExecution
        
        :raises:
            ignition.service.resourcedriver.RequestNotFoundError: if no request with the given request_id exists
        """
        kube_location = self.__translate_location(deployment_location)
        try:
            try:
                request_report = self.kegd_strategy_manager.get_request_report(kube_location, request_id)
            except RecordNotFoundError as e:
                raise RequestNotFoundError(f'{e}') from e
            execution_status = lifecycle_model.STATUS_IN_PROGRESS
            failure_details = None
            outputs = None
            if request_report.state == StrategyExecutionStates.COMPLETE:
                execution_status = lifecycle_model.STATUS_COMPLETE
                outputs = request_report.outputs
            elif request_report.state == StrategyExecutionStates.FAILED:
                execution_status = lifecycle_model.STATUS_FAILED
                failure_details = failure_model.FailureDetails(failure_model.FAILURE_CODE_INTERNAL_ERROR, description=str(request_report.errors))
            associated_topology = self.__build_associated_topology_from_delta(request_report.delta)
            return lifecycle_model.LifecycleExecution(request_id, execution_status, outputs=outputs, failure_details=failure_details, associated_topology=associated_topology)
        finally:
            try:
                logger.debug(f'Attempting to clean up deployment location related files')
                kube_location.clean()
            except Exception as e:
                logger.exception(f'Encountered an error whilst trying to clean up deployment location related files: {e}')

    def __build_associated_topology_from_delta(self, request_delta):
        if request_delta == None:
            return None
        deployed = request_delta.deployed
        removed = request_delta.removed
        associated_topology = KubeAssociatedTopology()
        if removed != None:
            if removed.objects != None:
                for obj in removed.objects:
                    associated_topology.add_removed_object(obj)
            if removed.helm_releases != None:
                for helm in removed.helm_releases:
                    if helm.objects_only is not True:
                        associated_topology.add_removed_helm_release(helm)
                    if helm.removed_objects != None:
                        for obj in helm.removed_objects:
                            associated_topology.add_removed_object(obj)
        if deployed != None:
            if deployed.objects != None:
                for obj in deployed.objects:
                    associated_topology.add_object(obj)
            if deployed.helm_releases != None:
                for helm in deployed.helm_releases:
                    if helm.objects_only is not True:
                        associated_topology.add_helm_release(helm)
                    if helm.deployed_objects != None:
                        for obj in helm.deployed_objects:
                            associated_topology.add_object(obj)
                    # May be an upgrade which could cause objects to be removed
                    if helm.removed_objects != None:
                        for obj in helm.removed_objects:
                            associated_topology.add_removed_object(obj)
        return associated_topology

    def post_lifecycle_response(self, request_id, deployment_location):
        """
        Clears the kegd report to keep Kubernetes clusters tidy. 
        This is only called if the lifecycle monitor has posted a message on Kafka (in response to Brent) so this is safe to do, as this request will not be checked again.
        """
        if self.resource_driver_properties.keep_kegdrs is False:
            kube_location = self.__translate_location(deployment_location)
            self.kegd_strategy_manager.delete_request_report(kube_location, request_id)

    def find_reference(self, instance_name, driver_files, deployment_location):
        """
        Find a Resource, returning the necessary property output values and internal resources from those instances

        :param str instance_name: name used to filter the Resource to find
        :param ignition.utils.file.DirectoryTree driver_files: object for navigating the directory intended for this driver from the Resource package. The user should call "remove_all" when the files are no longer needed
        :param dict deployment_location: the deployment location to find the instance in
        :return: an ignition.model.references.FindReferenceResponse

        :raises:
            ignition.service.resourcedriver.InvalidDriverFilesError: if the scripts are not valid
            ignition.service.resourcedriver.InvalidRequestError: if the request is invalid e.g. if no script can be found to execute the transition/operation given by lifecycle_name
            ignition.service.resourcedriver.TemporaryResourceDriverError: there is an issue handling this request at this time
            ignition.service.resourcedriver.ResourceDriverError: there was an error handling this request
        """
        raise NotImplementedError('Find Reference not yet implemented')

    def __translate_location(self, deployment_location_as_dict):
        return KubeDeploymentLocation.from_dict(deployment_location_as_dict)

    def __generate_keg_name(self, system_properties):
        resource_id = system_properties.get('resourceId')
        if resource_id == None:
            raise InvalidRequestError('system properties missing \'resourceId\' value')
        resource_name = system_properties.get('resourceName')
        if resource_name == None:
            raise InvalidRequestError('system properties missing \'resourceName\' value')
        return self.name_manager.safe_label_name_for_resource(resource_id, resource_name, prefix='keg')

    
