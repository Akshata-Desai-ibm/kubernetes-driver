import uuid
import ignition.model.infrastructure as infrastructure_model
import ignition.model.failure as failure_model
from ignition.service.framework import Service
from ignition.utils.propvaluemap import PropValueMap
from ignition.service.infrastructure import InfrastructureDriverCapability
from kubedriver.kubeobjects import ObjectConfigurationGroup, HelmReleaseConfiguration, namehelper
from kubedriver.manager.records import RequestStates, RequestOperations
import base64
import tempfile
import tarfile
import yaml
import os
import datetime
from kubedriver.helmclient import HelmClient

class InfrastructureDriver(Service, InfrastructureDriverCapability):

    def __init__(self, deployment_location_translator, object_manager, templating):
        self.deployment_location_translator = deployment_location_translator
        self.object_manager = object_manager
        self.templating = templating

    def __translate_location(self, deployment_location_dict):
        kube_location = self.deployment_location_translator.translate(deployment_location_dict)
        return kube_location

    def __build_render_properties(self, system_properties, properties):
        render_props = {k:v for k,v in properties.items()}
        sys_props = {k:v for k,v in system_properties.items()}
        render_props['systemProperties'] = sys_props
        self.__add_additional_render_properties(render_props)
        return render_props

    def __add_additional_render_properties(self, render_props):
        system_properties = render_props['systemProperties']
        if 'resourceId' in system_properties:
            system_properties['resourceIdSd'] = namehelper.safe_subdomain_name(system_properties.get('resourceId'))
            system_properties['resourceIdSubdomain'] = namehelper.safe_subdomain_name(system_properties.get('resourceId'))
        if 'resourceName' in system_properties:
            system_properties['resourceNameSd'] = namehelper.safe_subdomain_name(system_properties.get('resourceName'))
            system_properties['resourceNameSubdomain'] = namehelper.safe_subdomain_name(system_properties.get('resourceName'))

    def __process_template_to_objects(self, template, system_properties, properties):
        render_props = self.__build_render_properties(system_properties, properties)
        obj_conf_doc = self.templating.render_template(template, render_props)
        return obj_conf_doc.read()

    def __resource_unique_identifier(self, system_properties):
        if 'resourceId' in system_properties and 'resourceName' in system_properties:
            identifier = '{0}.{1}'.format(system_properties.get('resourceName'), system_properties.get('resourceId'))
        else:
            identifier = str(uuid.uuid4())
        return identifier

    def __helm_release_name(self, system_properties):
        if 'resourceName' in system_properties:
            release_name = '{0}-{1}'.format(system_properties.get('resourceName'), datetime.datetime.now().timestamp()).replace('.', '-')
        else:
            release_name = str(uuid.uuid4())
        return release_name

    def create_infrastructure(self, template, template_type, system_properties, properties, deployment_location):
        """
        Initiates a request to create infrastructure based on a TOSCA template.
        This method should return immediate response of the request being accepted,
        the InfrastructureService will poll get_infrastructure_task on this driver to determine when the request has completed.

        :param str template: template of infrastructure to be created
        :param str template_type: type of template used i.e. TOSCA or Heat
        :param ignition.utils.propvaluemap.PropValueMap system_properties: properties generated by LM for this Resource: resourceId, resourceName, requestId, metricKey, resourceManagerId, deploymentLocation, resourceType
        :param ignition.utils.propvaluemap.PropValueMap properties: property values of the Resource
        :param dict deployment_location: the deployment location to deploy to
        :return: an ignition.model.infrastructure.CreateInfrastructureResponse

        :raises:
            ignition.service.infrastructure.InvalidInfrastructureTemplateError: if the Template is not valid
            ignition.service.infrastructure.TemporaryInfrastructureError: there is an issue handling this request at this time
            ignition.service.infrastructure.UnreachableDeploymentLocationError: the Deployment Location cannot be reached
            ignition.service.infrastructure.InfrastructureError: there was an error handling this request
        """
        kube_location = self.__translate_location(deployment_location)
        if template_type == 'Helm':
            object_group = self.__build_helm_group(kube_location, template, system_properties, properties)
        elif template_type == 'ObjectConfiguration' or template_type == 'Kubernetes':
            object_group = self.__build_objects_group(kube_location, template, system_properties, properties)
        else:
            raise ValueError(f'Template type must be \'ObjectConfiguration\' or \'Kubernetes\' or \'Helm\' but was \'{template_type}\'')
        request_id = self.object_manager.create_group(kube_location, object_group)
        return infrastructure_model.CreateInfrastructureResponse(object_group.identifier, request_id)

    def __build_objects_group(self, kube_location, template, system_properties, properties):
        kube_objects = self.__process_template_to_objects(template, system_properties, properties)
        identifier = self.__resource_unique_identifier(system_properties)
        return ObjectConfigurationGroup(identifier, objects=kube_objects)

    def __build_helm_group(self, kube_location, template, system_properties, properties):
        chart_path, values_path = self.__write_template_to_disk(template)
        self.__template_helm_values(values_path, system_properties, properties)
        release_name = namehelper.safe_subdomain_name(self.__helm_release_name(system_properties))
        namespace = kube_location.default_object_namespace
        if 'namespace' in properties:
            namespace = properties.get('namespace')
        helm_release_configuration = HelmReleaseConfiguration(chart_path, release_name, namespace, values_path)
        identifier = self.__resource_unique_identifier(system_properties)
        return ObjectConfigurationGroup(identifier, helm_releases=[helm_release_configuration])

    def __template_helm_values(self, values_path, system_properties, properties):
        render_props = self.__build_render_properties(system_properties, properties)
        with open(values_path, 'r') as reader:
            template_output = self.templating.render_template_as_str(reader.read(), render_props)
        with open(values_path, 'w') as writer:
            writer.write(template_output)

    def __write_template_to_disk(self, template):
        charts_def = yaml.safe_load(template)
        chart_string = charts_def.get('chart')
        tmp_dir = tempfile.mkdtemp()
        chart_path = os.path.join(tmp_dir, 'chart.tgz')
        with open(chart_path, 'wb') as writer:
            writer.write(base64.b64decode(chart_string))
        values = charts_def.get('values', '')
        values_path = os.path.join(tmp_dir, 'values.yaml')
        with open(values_path, 'w') as writer:
            writer.write(values)
        return chart_path, values_path

    def get_infrastructure_task(self, infrastructure_id, request_id, deployment_location):
        """
        Get information about the infrastructure (created or deleted)

        :param str infrastructure_id: identifier of the infrastructure to check
        :param str request_id: identifier of the request to check
        :param dict deployment_location: the location the infrastructure was deployed to
        :return: an ignition.model.infrastructure.InfrastructureTask instance describing the status

        :raises:
            ignition.service.infrastructure.InfrastructureNotFoundError: if no infrastructure with the given infrastructure_id exists
            ignition.service.infrastructure.InfrastructureRequestNotFoundError: if no request with the given request_id exists
            ignition.service.infrastructure.UnreachableDeploymentLocationError: the Deployment Location cannot be reached
            ignition.service.infrastructure.TemporaryInfrastructureError: there is an issue handling this request at this time, an attempt should be made again at a later time
            ignition.service.infrastructure.InfrastructureError: there was an error handling this request
        """
        kube_location = self.__translate_location(deployment_location)
        request_record = self.object_manager.get_request_record(kube_location, infrastructure_id, request_id)
        task_status = infrastructure_model.STATUS_IN_PROGRESS
        failure_details = None
        if request_record.state == RequestStates.COMPLETE:
            task_status = infrastructure_model.STATUS_COMPLETE
            if request_record.operation == RequestOperations.DELETE:
                # Purge record of this Group after the Delete completes so we don't create a build up of zombie persistence records
                self.object_manager.purge_group(kube_location, infrastructure_id)
        elif request_record.state == RequestStates.FAILED:
            task_status = infrastructure_model.STATUS_FAILED
            failure_details = failure_model.FailureDetails(failure_model.FAILURE_CODE_INTERNAL_ERROR, description=request_record.error)
        return infrastructure_model.InfrastructureTask(infrastructure_id, request_id, task_status, failure_details=failure_details, outputs={})

    def delete_infrastructure(self, infrastructure_id, deployment_location):
        """
        Initiates a request to delete infrastructure previously created with the given infrastructure_id.
        This method should return immediate response of the request being accepted,
        the InfrastructureService will poll get_infrastructure_task on this driver to determine when the request has completed.

        :param str infrastructure_id: identifier of the infrastructure to be removed
        :param dict deployment_location: the location the infrastructure was deployed to
        :return: an ignition.model.infrastructure.DeleteInfrastructureResponse

        :raises:
            ignition.service.infrastructure.InfrastructureNotFoundError: if no infrastructure with the given infrastructure_id exists
            ignition.service.infrastructure.UnreachableDeploymentLocationError: the Deployment Location cannot be reached
            ignition.service.infrastructure.TemporaryInfrastructureError: there is an issue handling this request at this time, an attempt should be made again at a later time
            ignition.service.infrastructure.InfrastructureError: there was an error handling this request
        """
        kube_location = self.__translate_location(deployment_location)
        request_id = self.object_manager.delete_group(kube_location, infrastructure_id)
        return infrastructure_model.DeleteInfrastructureResponse(infrastructure_id, request_id)

    def find_infrastructure(self, template, template_type, instance_name, deployment_location):
        """
        Finds infrastructure instances that meet the requirements set out in the given TOSCA template, returning the desired output values from those instances

        :param str template: tosca template of infrastructure to be found
        :param str template_type: type of template used i.e. TOSCA or Heat
        :param str instance_name: name given as search criteria
        :param dict deployment_location: the deployment location to deploy to
        :return: an ignition.model.infrastructure.FindInfrastructureResponse

        :raises:
            ignition.service.infrastructure.InvalidInfrastructureTemplateError: if the Template is not valid
            ignition.service.infrastructure.UnreachableDeploymentLocationError: the Deployment Location cannot be reached
            ignition.service.infrastructure.TemporaryInfrastructureError: there is an issue handling this request at this time, an attempt should be made again at a later time
            ignition.service.infrastructure.InfrastructureError: there was an error handling this request
        """
        raise NotImplementedError('find_infrastructure not yet implemented')